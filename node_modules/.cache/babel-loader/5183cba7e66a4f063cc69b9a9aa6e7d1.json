{"remainingRequest":"C:\\Users\\USER\\Desktop\\IoT-Heros\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\USER\\Desktop\\IoT-Heros\\node_modules\\eslint-loader\\index.js??ref--13-0!C:\\Users\\USER\\Desktop\\IoT-Heros\\bower_components\\jsartoolkit5\\js\\artoolkit.three.js","dependencies":[{"path":"C:\\Users\\USER\\Desktop\\IoT-Heros\\bower_components\\jsartoolkit5\\js\\artoolkit.three.js","mtime":1544694656018},{"path":"C:\\Users\\USER\\Desktop\\IoT-Heros\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\USER\\Desktop\\IoT-Heros\\node_modules\\babel-loader\\lib\\index.js","mtime":1492805601000},{"path":"C:\\Users\\USER\\Desktop\\IoT-Heros\\node_modules\\eslint-loader\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["/* THREE.js ARToolKit integration */\n\n;(function () {\n\tvar integrate = function () {\n\t\t/**\n  \tHelper for setting up a Three.js AR scene using the device camera as input.\n  \tPass in the maximum dimensions of the video you want to process and onSuccess and onError callbacks.\n  \t\tOn a successful initialization, the onSuccess callback is called with an ThreeARScene object.\n  \tThe ThreeARScene object contains two THREE.js scenes (one for the video image and other for the 3D scene)\n  \tand a couple of helper functions for doing video frame processing and AR rendering.\n  \t\tHere's the structure of the ThreeARScene object:\n  \t{\n  \t\tscene: THREE.Scene, // The 3D scene. Put your AR objects here.\n  \t\tcamera: THREE.Camera, // The 3D scene camera.\n  \t\t\tarController: ARController,\n  \t\t\tvideo: HTMLVideoElement, // The userMedia video element.\n  \t\t\tvideoScene: THREE.Scene, // The userMedia video image scene. Shows the video feed.\n  \t\tvideoCamera: THREE.Camera, // Camera for the userMedia video scene.\n  \t\t\tprocess: function(), // Process the current video frame and update the markers in the scene.\n  \t\trenderOn: function( THREE.WebGLRenderer ) // Render the AR scene and video background on the given Three.js renderer.\n  \t}\n  \t\tYou should use the arScene.video.videoWidth and arScene.video.videoHeight to set the width and height of your renderer.\n  \t\tIn your frame loop, use arScene.process() and arScene.renderOn(renderer) to do frame processing and 3D rendering, respectively.\n  \t\t@param {number} width - The maximum width of the userMedia video to request.\n  \t@param {number} height - The maximum height of the userMedia video to request.\n  \t@param {function} onSuccess - Called on successful initialization with an ThreeARScene object.\n  \t@param {function} onError - Called if the initialization fails with the error encountered.\n  */\n\t\tARController.getUserMediaThreeScene = function (configuration) {\n\t\t\tvar obj = {};\n\t\t\tfor (var i in configuration) {\n\t\t\t\tobj[i] = configuration[i];\n\t\t\t}\n\t\t\tvar onSuccess = configuration.onSuccess;\n\n\t\t\tobj.onSuccess = function (arController, arCameraParam) {\n\t\t\t\tvar scenes = arController.createThreeScene();\n\t\t\t\tonSuccess(scenes, arController, arCameraParam);\n\t\t\t};\n\n\t\t\tvar video = this.getUserMediaARController(obj);\n\t\t\treturn video;\n\t\t};\n\n\t\t/**\n  \tCreates a Three.js scene for use with this ARController.\n  \t\tReturns a ThreeARScene object that contains two THREE.js scenes (one for the video image and other for the 3D scene)\n  \tand a couple of helper functions for doing video frame processing and AR rendering.\n  \t\tHere's the structure of the ThreeARScene object:\n  \t{\n  \t\tscene: THREE.Scene, // The 3D scene. Put your AR objects here.\n  \t\tcamera: THREE.Camera, // The 3D scene camera.\n  \t\t\tarController: ARController,\n  \t\t\tvideo: HTMLVideoElement, // The userMedia video element.\n  \t\t\tvideoScene: THREE.Scene, // The userMedia video image scene. Shows the video feed.\n  \t\tvideoCamera: THREE.Camera, // Camera for the userMedia video scene.\n  \t\t\tprocess: function(), // Process the current video frame and update the markers in the scene.\n  \t\trenderOn: function( THREE.WebGLRenderer ) // Render the AR scene and video background on the given Three.js renderer.\n  \t}\n  \t\tYou should use the arScene.video.videoWidth and arScene.video.videoHeight to set the width and height of your renderer.\n  \t\tIn your frame loop, use arScene.process() and arScene.renderOn(renderer) to do frame processing and 3D rendering, respectively.\n  \t\t@param video Video image to use as scene background. Defaults to this.image\n  */\n\t\tARController.prototype.createThreeScene = function (video) {\n\t\t\tvideo = video || this.image;\n\n\t\t\tthis.setupThree();\n\n\t\t\t// To display the video, first create a texture from it.\n\t\t\tvar videoTex = new THREE.Texture(video);\n\n\t\t\tvideoTex.minFilter = THREE.LinearFilter;\n\t\t\tvideoTex.flipY = false;\n\n\t\t\t// Then create a plane textured with the video.\n\t\t\tvar plane = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), new THREE.MeshBasicMaterial({ map: videoTex, side: THREE.DoubleSide }));\n\n\t\t\t// The video plane shouldn't care about the z-buffer.\n\t\t\tplane.material.depthTest = false;\n\t\t\tplane.material.depthWrite = false;\n\n\t\t\t// Create a camera and a scene for the video plane and\n\t\t\t// add the camera and the video plane to the scene.\n\t\t\tvar videoCamera = new THREE.OrthographicCamera(-1, 1, -1, 1, -1, 1);\n\t\t\tvar videoScene = new THREE.Scene();\n\t\t\tvideoScene.add(plane);\n\t\t\tvideoScene.add(videoCamera);\n\n\t\t\tif (this.orientation === 'portrait') {\n\t\t\t\tplane.rotation.z = Math.PI / 2;\n\t\t\t}\n\n\t\t\tvar scene = new THREE.Scene();\n\t\t\tvar camera = new THREE.Camera();\n\t\t\tcamera.matrixAutoUpdate = false;\n\t\t\tcamera.projectionMatrix.fromArray(this.getCameraMatrix());\n\n\t\t\tscene.add(camera);\n\n\t\t\tvar self = this;\n\n\t\t\treturn {\n\t\t\t\tscene: scene,\n\t\t\t\tvideoScene: videoScene,\n\t\t\t\tcamera: camera,\n\t\t\t\tvideoCamera: videoCamera,\n\n\t\t\t\tarController: this,\n\n\t\t\t\tvideo: video,\n\n\t\t\t\tprocess: function () {\n\t\t\t\t\tfor (var i in self.threePatternMarkers) {\n\t\t\t\t\t\tself.threePatternMarkers[i].visible = false;\n\t\t\t\t\t}\n\t\t\t\t\tfor (var i in self.threeBarcodeMarkers) {\n\t\t\t\t\t\tself.threeBarcodeMarkers[i].visible = false;\n\t\t\t\t\t}\n\t\t\t\t\tfor (var i in self.threeMultiMarkers) {\n\t\t\t\t\t\tself.threeMultiMarkers[i].visible = false;\n\t\t\t\t\t\tfor (var j = 0; j < self.threeMultiMarkers[i].markers.length; j++) {\n\t\t\t\t\t\t\tif (self.threeMultiMarkers[i].markers[j]) {\n\t\t\t\t\t\t\t\tself.threeMultiMarkers[i].markers[j].visible = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tself.process(video);\n\t\t\t\t},\n\n\t\t\t\trenderOn: function (renderer) {\n\t\t\t\t\tvideoTex.needsUpdate = true;\n\n\t\t\t\t\tvar ac = renderer.autoClear;\n\t\t\t\t\trenderer.autoClear = false;\n\t\t\t\t\trenderer.clear();\n\t\t\t\t\trenderer.render(this.videoScene, this.videoCamera);\n\t\t\t\t\trenderer.render(this.scene, this.camera);\n\t\t\t\t\trenderer.autoClear = ac;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t\t/**\n  \tCreates a Three.js marker Object3D for the given marker UID.\n  \tThe marker Object3D tracks the marker pattern when it's detected in the video.\n  \t\tUse this after a successful artoolkit.loadMarker call:\n  \t\tarController.loadMarker('/bin/Data/patt.hiro', function(markerUID) {\n  \t\tvar markerRoot = arController.createThreeMarker(markerUID);\n  \t\tmarkerRoot.add(myFancyHiroModel);\n  \t\tarScene.scene.add(markerRoot);\n  \t});\n  \t\t@param {number} markerUID The UID of the marker to track.\n  \t@param {number} markerWidth The width of the marker, defaults to 1.\n  \t@return {THREE.Object3D} Three.Object3D that tracks the given marker.\n  */\n\t\tARController.prototype.createThreeMarker = function (markerUID, markerWidth) {\n\t\t\tthis.setupThree();\n\t\t\tvar obj = new THREE.Object3D();\n\t\t\tobj.markerTracker = this.trackPatternMarkerId(markerUID, markerWidth);\n\t\t\tobj.matrixAutoUpdate = false;\n\t\t\tthis.threePatternMarkers[markerUID] = obj;\n\t\t\treturn obj;\n\t\t};\n\n\t\t/**\n  \tCreates a Three.js marker Object3D for the given multimarker UID.\n  \tThe marker Object3D tracks the multimarker when it's detected in the video.\n  \t\tUse this after a successful arController.loadMarker call:\n  \t\tarController.loadMultiMarker('/bin/Data/multi-barcode-4x3.dat', function(markerUID) {\n  \t\tvar markerRoot = arController.createThreeMultiMarker(markerUID);\n  \t\tmarkerRoot.add(myFancyMultiMarkerModel);\n  \t\tarScene.scene.add(markerRoot);\n  \t});\n  \t\t@param {number} markerUID The UID of the marker to track.\n  \t@return {THREE.Object3D} Three.Object3D that tracks the given marker.\n  */\n\t\tARController.prototype.createThreeMultiMarker = function (markerUID) {\n\t\t\tthis.setupThree();\n\t\t\tvar obj = new THREE.Object3D();\n\t\t\tobj.matrixAutoUpdate = false;\n\t\t\tobj.markers = [];\n\t\t\tthis.threeMultiMarkers[markerUID] = obj;\n\t\t\treturn obj;\n\t\t};\n\n\t\t/**\n  \tCreates a Three.js marker Object3D for the given barcode marker UID.\n  \tThe marker Object3D tracks the marker pattern when it's detected in the video.\n  \t\tvar markerRoot20 = arController.createThreeBarcodeMarker(20);\n  \tmarkerRoot20.add(myFancyNumber20Model);\n  \tarScene.scene.add(markerRoot20);\n  \t\tvar markerRoot5 = arController.createThreeBarcodeMarker(5);\n  \tmarkerRoot5.add(myFancyNumber5Model);\n  \tarScene.scene.add(markerRoot5);\n  \t\t@param {number} markerUID The UID of the barcode marker to track.\n  \t@param {number} markerWidth The width of the marker, defaults to 1.\n  \t@return {THREE.Object3D} Three.Object3D that tracks the given marker.\n  */\n\t\tARController.prototype.createThreeBarcodeMarker = function (markerUID, markerWidth) {\n\t\t\tthis.setupThree();\n\t\t\tvar obj = new THREE.Object3D();\n\t\t\tobj.markerTracker = this.trackBarcodeMarkerId(markerUID, markerWidth);\n\t\t\tobj.matrixAutoUpdate = false;\n\t\t\tthis.threeBarcodeMarkers[markerUID] = obj;\n\t\t\treturn obj;\n\t\t};\n\n\t\tARController.prototype.setupThree = function () {\n\t\t\tif (this.THREE_JS_ENABLED) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.THREE_JS_ENABLED = true;\n\n\t\t\t/*\n   \tListen to getMarker events to keep track of Three.js markers.\n   */\n\t\t\tthis.addEventListener('getMarker', function (ev) {\n\t\t\t\tvar marker = ev.data.marker;\n\t\t\t\tvar obj;\n\t\t\t\tif (ev.data.type === artoolkit.PATTERN_MARKER) {\n\t\t\t\t\tobj = this.threePatternMarkers[ev.data.marker.idPatt];\n\t\t\t\t} else if (ev.data.type === artoolkit.BARCODE_MARKER) {\n\t\t\t\t\tobj = this.threeBarcodeMarkers[ev.data.marker.idMatrix];\n\t\t\t\t}\n\t\t\t\tif (obj) {\n\t\t\t\t\tobj.matrix.fromArray(ev.data.matrix);\n\t\t\t\t\tobj.visible = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/*\n   \tListen to getMultiMarker events to keep track of Three.js multimarkers.\n   */\n\t\t\tthis.addEventListener('getMultiMarker', function (ev) {\n\t\t\t\tvar obj = this.threeMultiMarkers[ev.data.multiMarkerId];\n\t\t\t\tif (obj) {\n\t\t\t\t\tobj.matrix.fromArray(ev.data.matrix);\n\t\t\t\t\tobj.visible = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/*\n   \tListen to getMultiMarkerSub events to keep track of Three.js multimarker submarkers.\n   */\n\t\t\tthis.addEventListener('getMultiMarkerSub', function (ev) {\n\t\t\t\tvar marker = ev.data.multiMarkerId;\n\t\t\t\tvar subMarkerID = ev.data.markerIndex;\n\t\t\t\tvar subMarker = ev.data.marker;\n\t\t\t\tvar obj = this.threeMultiMarkers[marker];\n\t\t\t\tif (obj && obj.markers && obj.markers[subMarkerID]) {\n\t\t\t\t\tvar sub = obj.markers[subMarkerID];\n\t\t\t\t\tsub.matrix.fromArray(ev.data.matrix);\n\t\t\t\t\tsub.visible = subMarker.visible >= 0;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/**\n   \tIndex of Three.js pattern markers, maps markerID -> THREE.Object3D.\n   */\n\t\t\tthis.threePatternMarkers = {};\n\n\t\t\t/**\n   \tIndex of Three.js barcode markers, maps markerID -> THREE.Object3D.\n   */\n\t\t\tthis.threeBarcodeMarkers = {};\n\n\t\t\t/**\n   \tIndex of Three.js multimarkers, maps markerID -> THREE.Object3D.\n   */\n\t\t\tthis.threeMultiMarkers = {};\n\t\t};\n\t};\n\n\tvar tick = function () {\n\t\tif (window.ARController && window.THREE) {\n\t\t\tintegrate();\n\t\t\tif (window.ARThreeOnLoad) {\n\t\t\t\twindow.ARThreeOnLoad();\n\t\t\t}\n\t\t} else {\n\t\t\tsetTimeout(tick, 50);\n\t\t}\n\t};\n\n\ttick();\n})();",{"version":3,"sources":["bower_components\\jsartoolkit5\\js\\artoolkit.three.js"],"names":["integrate","ARController","getUserMediaThreeScene","configuration","obj","i","onSuccess","arController","arCameraParam","scenes","createThreeScene","video","getUserMediaARController","prototype","image","setupThree","videoTex","THREE","Texture","minFilter","LinearFilter","flipY","plane","Mesh","PlaneBufferGeometry","MeshBasicMaterial","map","side","DoubleSide","material","depthTest","depthWrite","videoCamera","OrthographicCamera","videoScene","Scene","add","orientation","rotation","z","Math","PI","scene","camera","Camera","matrixAutoUpdate","projectionMatrix","fromArray","getCameraMatrix","self","process","threePatternMarkers","visible","threeBarcodeMarkers","threeMultiMarkers","j","markers","length","renderOn","renderer","needsUpdate","ac","autoClear","clear","render","createThreeMarker","markerUID","markerWidth","Object3D","markerTracker","trackPatternMarkerId","createThreeMultiMarker","createThreeBarcodeMarker","trackBarcodeMarkerId","THREE_JS_ENABLED","addEventListener","ev","marker","data","type","artoolkit","PATTERN_MARKER","idPatt","BARCODE_MARKER","idMatrix","matrix","multiMarkerId","subMarkerID","markerIndex","subMarker","sub","tick","window","ARThreeOnLoad","setTimeout"],"mappings":"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","file":"artoolkit.three.js","sourceRoot":"C:/Users/USER/Desktop/IoT-Heros","sourcesContent":["/* THREE.js ARToolKit integration */\n\n;(function() {\n\tvar integrate = function() {\n\t\t/**\n\t\t\tHelper for setting up a Three.js AR scene using the device camera as input.\n\t\t\tPass in the maximum dimensions of the video you want to process and onSuccess and onError callbacks.\n\n\t\t\tOn a successful initialization, the onSuccess callback is called with an ThreeARScene object.\n\t\t\tThe ThreeARScene object contains two THREE.js scenes (one for the video image and other for the 3D scene)\n\t\t\tand a couple of helper functions for doing video frame processing and AR rendering.\n\n\t\t\tHere's the structure of the ThreeARScene object:\n\t\t\t{\n\t\t\t\tscene: THREE.Scene, // The 3D scene. Put your AR objects here.\n\t\t\t\tcamera: THREE.Camera, // The 3D scene camera.\n\n\t\t\t\tarController: ARController,\n\n\t\t\t\tvideo: HTMLVideoElement, // The userMedia video element.\n\n\t\t\t\tvideoScene: THREE.Scene, // The userMedia video image scene. Shows the video feed.\n\t\t\t\tvideoCamera: THREE.Camera, // Camera for the userMedia video scene.\n\n\t\t\t\tprocess: function(), // Process the current video frame and update the markers in the scene.\n\t\t\t\trenderOn: function( THREE.WebGLRenderer ) // Render the AR scene and video background on the given Three.js renderer.\n\t\t\t}\n\n\t\t\tYou should use the arScene.video.videoWidth and arScene.video.videoHeight to set the width and height of your renderer.\n\n\t\t\tIn your frame loop, use arScene.process() and arScene.renderOn(renderer) to do frame processing and 3D rendering, respectively.\n\n\t\t\t@param {number} width - The maximum width of the userMedia video to request.\n\t\t\t@param {number} height - The maximum height of the userMedia video to request.\n\t\t\t@param {function} onSuccess - Called on successful initialization with an ThreeARScene object.\n\t\t\t@param {function} onError - Called if the initialization fails with the error encountered.\n\t\t*/\n\t\tARController.getUserMediaThreeScene = function(configuration) {\n\t\t\tvar obj = {};\n\t\t\tfor (var i in configuration) {\n\t\t\t\tobj[i] = configuration[i];\n\t\t\t}\n\t\t\tvar onSuccess = configuration.onSuccess;\n\n\t\t\tobj.onSuccess = function(arController, arCameraParam) {\n\t\t\t\tvar scenes = arController.createThreeScene();\n\t\t\t\tonSuccess(scenes, arController, arCameraParam);\n\t\t\t};\n\n\t\t\tvar video = this.getUserMediaARController(obj);\n\t\t\treturn video;\n\t\t};\n\n\t\t/**\n\t\t\tCreates a Three.js scene for use with this ARController.\n\n\t\t\tReturns a ThreeARScene object that contains two THREE.js scenes (one for the video image and other for the 3D scene)\n\t\t\tand a couple of helper functions for doing video frame processing and AR rendering.\n\n\t\t\tHere's the structure of the ThreeARScene object:\n\t\t\t{\n\t\t\t\tscene: THREE.Scene, // The 3D scene. Put your AR objects here.\n\t\t\t\tcamera: THREE.Camera, // The 3D scene camera.\n\n\t\t\t\tarController: ARController,\n\n\t\t\t\tvideo: HTMLVideoElement, // The userMedia video element.\n\n\t\t\t\tvideoScene: THREE.Scene, // The userMedia video image scene. Shows the video feed.\n\t\t\t\tvideoCamera: THREE.Camera, // Camera for the userMedia video scene.\n\n\t\t\t\tprocess: function(), // Process the current video frame and update the markers in the scene.\n\t\t\t\trenderOn: function( THREE.WebGLRenderer ) // Render the AR scene and video background on the given Three.js renderer.\n\t\t\t}\n\n\t\t\tYou should use the arScene.video.videoWidth and arScene.video.videoHeight to set the width and height of your renderer.\n\n\t\t\tIn your frame loop, use arScene.process() and arScene.renderOn(renderer) to do frame processing and 3D rendering, respectively.\n\n\t\t\t@param video Video image to use as scene background. Defaults to this.image\n\t\t*/\n\t\tARController.prototype.createThreeScene = function(video) {\n\t\t\tvideo = video || this.image;\n\n\t\t\tthis.setupThree();\n\n\t\t\t// To display the video, first create a texture from it.\n\t\t\tvar videoTex = new THREE.Texture(video);\n\n\t\t\tvideoTex.minFilter = THREE.LinearFilter;\n\t\t\tvideoTex.flipY = false;\n\n\t\t\t// Then create a plane textured with the video.\n\t\t\tvar plane = new THREE.Mesh(\n\t\t\t  new THREE.PlaneBufferGeometry(2, 2),\n\t\t\t  new THREE.MeshBasicMaterial({map: videoTex, side: THREE.DoubleSide})\n\t\t\t);\n\n\t\t\t// The video plane shouldn't care about the z-buffer.\n\t\t\tplane.material.depthTest = false;\n\t\t\tplane.material.depthWrite = false;\n\n\t\t\t// Create a camera and a scene for the video plane and\n\t\t\t// add the camera and the video plane to the scene.\n\t\t\tvar videoCamera = new THREE.OrthographicCamera(-1, 1, -1, 1, -1, 1);\n\t\t\tvar videoScene = new THREE.Scene();\n\t\t\tvideoScene.add(plane);\n\t\t\tvideoScene.add(videoCamera);\n\n\t\t\tif (this.orientation === 'portrait') {\n\t\t\t\tplane.rotation.z = Math.PI/2;\n\t\t\t}\n\n\t\t\tvar scene = new THREE.Scene();\n\t\t\tvar camera = new THREE.Camera();\n\t\t\tcamera.matrixAutoUpdate = false;\n\t\t\tcamera.projectionMatrix.fromArray(this.getCameraMatrix());\n\n\t\t\tscene.add(camera);\n\n\n\t\t\tvar self = this;\n\n\t\t\treturn {\n\t\t\t\tscene: scene,\n\t\t\t\tvideoScene: videoScene,\n\t\t\t\tcamera: camera,\n\t\t\t\tvideoCamera: videoCamera,\n\n\t\t\t\tarController: this,\n\n\t\t\t\tvideo: video,\n\n\t\t\t\tprocess: function() {\n\t\t\t\t\tfor (var i in self.threePatternMarkers) {\n\t\t\t\t\t\tself.threePatternMarkers[i].visible = false;\n\t\t\t\t\t}\n\t\t\t\t\tfor (var i in self.threeBarcodeMarkers) {\n\t\t\t\t\t\tself.threeBarcodeMarkers[i].visible = false;\n\t\t\t\t\t}\n\t\t\t\t\tfor (var i in self.threeMultiMarkers) {\n\t\t\t\t\t\tself.threeMultiMarkers[i].visible = false;\n\t\t\t\t\t\tfor (var j=0; j<self.threeMultiMarkers[i].markers.length; j++) {\n\t\t\t\t\t\t\tif (self.threeMultiMarkers[i].markers[j]) {\n\t\t\t\t\t\t\t\tself.threeMultiMarkers[i].markers[j].visible = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tself.process(video);\n\t\t\t\t},\n\n\t\t\t\trenderOn: function(renderer) {\n\t\t\t\t\tvideoTex.needsUpdate = true;\n\n\t\t\t\t\tvar ac = renderer.autoClear;\n\t\t\t\t\trenderer.autoClear = false;\n\t\t\t\t\trenderer.clear();\n\t\t\t\t\trenderer.render(this.videoScene, this.videoCamera);\n\t\t\t\t\trenderer.render(this.scene, this.camera);\n\t\t\t\t\trenderer.autoClear = ac;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\n\t\t/**\n\t\t\tCreates a Three.js marker Object3D for the given marker UID.\n\t\t\tThe marker Object3D tracks the marker pattern when it's detected in the video.\n\n\t\t\tUse this after a successful artoolkit.loadMarker call:\n\n\t\t\tarController.loadMarker('/bin/Data/patt.hiro', function(markerUID) {\n\t\t\t\tvar markerRoot = arController.createThreeMarker(markerUID);\n\t\t\t\tmarkerRoot.add(myFancyHiroModel);\n\t\t\t\tarScene.scene.add(markerRoot);\n\t\t\t});\n\n\t\t\t@param {number} markerUID The UID of the marker to track.\n\t\t\t@param {number} markerWidth The width of the marker, defaults to 1.\n\t\t\t@return {THREE.Object3D} Three.Object3D that tracks the given marker.\n\t\t*/\n\t\tARController.prototype.createThreeMarker = function(markerUID, markerWidth) {\n\t\t\tthis.setupThree();\n\t\t\tvar obj = new THREE.Object3D();\n\t\t\tobj.markerTracker = this.trackPatternMarkerId(markerUID, markerWidth);\n\t\t\tobj.matrixAutoUpdate = false;\n\t\t\tthis.threePatternMarkers[markerUID] = obj;\n\t\t\treturn obj;\n\t\t};\n\n\t\t/**\n\t\t\tCreates a Three.js marker Object3D for the given multimarker UID.\n\t\t\tThe marker Object3D tracks the multimarker when it's detected in the video.\n\n\t\t\tUse this after a successful arController.loadMarker call:\n\n\t\t\tarController.loadMultiMarker('/bin/Data/multi-barcode-4x3.dat', function(markerUID) {\n\t\t\t\tvar markerRoot = arController.createThreeMultiMarker(markerUID);\n\t\t\t\tmarkerRoot.add(myFancyMultiMarkerModel);\n\t\t\t\tarScene.scene.add(markerRoot);\n\t\t\t});\n\n\t\t\t@param {number} markerUID The UID of the marker to track.\n\t\t\t@return {THREE.Object3D} Three.Object3D that tracks the given marker.\n\t\t*/\n\t\tARController.prototype.createThreeMultiMarker = function(markerUID) {\n\t\t\tthis.setupThree();\n\t\t\tvar obj = new THREE.Object3D();\n\t\t\tobj.matrixAutoUpdate = false;\n\t\t\tobj.markers = [];\n\t\t\tthis.threeMultiMarkers[markerUID] = obj;\n\t\t\treturn obj;\n\t\t};\n\n\t\t/**\n\t\t\tCreates a Three.js marker Object3D for the given barcode marker UID.\n\t\t\tThe marker Object3D tracks the marker pattern when it's detected in the video.\n\n\t\t\tvar markerRoot20 = arController.createThreeBarcodeMarker(20);\n\t\t\tmarkerRoot20.add(myFancyNumber20Model);\n\t\t\tarScene.scene.add(markerRoot20);\n\n\t\t\tvar markerRoot5 = arController.createThreeBarcodeMarker(5);\n\t\t\tmarkerRoot5.add(myFancyNumber5Model);\n\t\t\tarScene.scene.add(markerRoot5);\n\n\t\t\t@param {number} markerUID The UID of the barcode marker to track.\n\t\t\t@param {number} markerWidth The width of the marker, defaults to 1.\n\t\t\t@return {THREE.Object3D} Three.Object3D that tracks the given marker.\n\t\t*/\n\t\tARController.prototype.createThreeBarcodeMarker = function(markerUID, markerWidth) {\n\t\t\tthis.setupThree();\n\t\t\tvar obj = new THREE.Object3D();\n\t\t\tobj.markerTracker = this.trackBarcodeMarkerId(markerUID, markerWidth);\n\t\t\tobj.matrixAutoUpdate = false;\n\t\t\tthis.threeBarcodeMarkers[markerUID] = obj;\n\t\t\treturn obj;\n\t\t};\n\n\t\tARController.prototype.setupThree = function() {\n\t\t\tif (this.THREE_JS_ENABLED) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.THREE_JS_ENABLED = true;\n\n\t\t\t/*\n\t\t\t\tListen to getMarker events to keep track of Three.js markers.\n\t\t\t*/\n\t\t\tthis.addEventListener('getMarker', function(ev) {\n\t\t\t\tvar marker = ev.data.marker;\n\t\t\t\tvar obj;\n\t\t\t\tif (ev.data.type === artoolkit.PATTERN_MARKER) {\n\t\t\t\t\tobj = this.threePatternMarkers[ev.data.marker.idPatt];\n\n\t\t\t\t} else if (ev.data.type === artoolkit.BARCODE_MARKER) {\n\t\t\t\t\tobj = this.threeBarcodeMarkers[ev.data.marker.idMatrix];\n\n\t\t\t\t}\n\t\t\t\tif (obj) {\n\t\t\t\t\tobj.matrix.fromArray(ev.data.matrix);\n\t\t\t\t\tobj.visible = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/*\n\t\t\t\tListen to getMultiMarker events to keep track of Three.js multimarkers.\n\t\t\t*/\n\t\t\tthis.addEventListener('getMultiMarker', function(ev) {\n\t\t\t\tvar obj = this.threeMultiMarkers[ev.data.multiMarkerId];\n\t\t\t\tif (obj) {\n\t\t\t\t\tobj.matrix.fromArray(ev.data.matrix);\n\t\t\t\t\tobj.visible = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/*\n\t\t\t\tListen to getMultiMarkerSub events to keep track of Three.js multimarker submarkers.\n\t\t\t*/\n\t\t\tthis.addEventListener('getMultiMarkerSub', function(ev) {\n\t\t\t\tvar marker = ev.data.multiMarkerId;\n\t\t\t\tvar subMarkerID = ev.data.markerIndex;\n\t\t\t\tvar subMarker = ev.data.marker;\n\t\t\t\tvar obj = this.threeMultiMarkers[marker];\n\t\t\t\tif (obj && obj.markers && obj.markers[subMarkerID]) {\n\t\t\t\t\tvar sub = obj.markers[subMarkerID];\n\t\t\t\t\tsub.matrix.fromArray(ev.data.matrix);\n\t\t\t\t\tsub.visible = (subMarker.visible >= 0);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/**\n\t\t\t\tIndex of Three.js pattern markers, maps markerID -> THREE.Object3D.\n\t\t\t*/\n\t\t\tthis.threePatternMarkers = {};\n\n\t\t\t/**\n\t\t\t\tIndex of Three.js barcode markers, maps markerID -> THREE.Object3D.\n\t\t\t*/\n\t\t\tthis.threeBarcodeMarkers = {};\n\n\t\t\t/**\n\t\t\t\tIndex of Three.js multimarkers, maps markerID -> THREE.Object3D.\n\t\t\t*/\n\t\t\tthis.threeMultiMarkers = {};\n\t\t};\n\n\t};\n\n\n\tvar tick = function() {\n\t\tif (window.ARController && window.THREE) {\n\t\t\tintegrate();\n\t\t\tif (window.ARThreeOnLoad) {\n\t\t\t\twindow.ARThreeOnLoad();\n\t\t\t}\n\t\t} else {\n\t\t\tsetTimeout(tick, 50);\n\t\t}\t\t\t\n\t};\n\n\ttick();\n\n})();\n"]}]}